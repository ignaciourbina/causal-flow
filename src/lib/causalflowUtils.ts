import type { Variable, Path, NodeIdentifier } from '@/types/causalflow';

export function generateLavaanScript(
  variables: Variable[],
  paths: Path[],
): string {
  if (!variables.length || !paths.length) {
    return "# No paths defined or variables missing.";
  }

  const variableMap = new Map(variables.map(v => [v.id, v.name]));
  const scriptLines: string[] = ['# Path Model generated by CausalFlow'];

  paths.forEach(path => {
    const fromName = variableMap.get(path.from.variableId);
    const toName = variableMap.get(path.to.variableId);

    if (!fromName || !toName) {
      console.warn(`Skipping path due to missing variable names: ${JSON.stringify(path)}`);
      return;
    }

    // Lavaan typically uses 1-based indexing for periods/waves, if periods are part of names
    const fromLavaanName = `${fromName}_t${path.from.periodIndex + 1}`;
    const toLavaanName = `${toName}_t${path.to.periodIndex + 1}`;
    
    // Ensure no self-regression on the exact same node instance
    if (fromLavaanName === toLavaanName) {
        scriptLines.push(`# Covariance for ${fromLavaanName} (e.g., ${fromLavaanName} ~~ ${fromLavaanName}) can be specified for variance`);
        return;
    }

    // Causal paths are typically regressions
    scriptLines.push(`${toLavaanName} ~ ${fromLavaanName}`);
  });

  if (scriptLines.length === 1) { // Only the header comment
    return "# No valid paths to export.";
  }

  return scriptLines.join('\n');
}
